# HCache 性能测试报告

本文档总结了HCache的性能测试结果，包括基准测试、压力测试和淘汰策略性能比较。所有测试均在相同硬件环境下进行，测试至少重复3次以确保数据的稳定性和可靠性。

**测试环境**：
- CPU: AMD Ryzen 5 5600G with Radeon Graphics
- 操作系统: Windows 10
- Go版本: 1.18+

## 1. 基准测试 (Benchmark)

基准测试主要用于评估缓存在不同操作下的性能，包括读取（命中/未命中）、写入（新值/更新）和混合负载场景。每项测试均重复3次，每次测试持续3秒，以确保结果稳定。

### 1.1 基本操作性能

| 操作类型 | 缓存大小 | 性能 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) |
|---------|---------|-------------|----------------|---------------------|
| Get/Hit | 1,000   | 97.47       | 0              | 0                   |
| Get/Hit | 10,000  | 97.31       | 0              | 0                   |
| Get/Hit | 100,000 | 98.98       | 0              | 0                   |
| Get/Miss | 1,000  | 128.33      | 24             | 2                   |
| Get/Miss | 10,000 | 129.30      | 24             | 1                   |
| Get/Miss | 100,000| 123.87      | 24             | 1                   |
| Set/New | 1,000   | 439.13      | 72.7           | 3                   |
| Set/New | 10,000  | 442.03      | 72.3           | 3                   |
| Set/New | 100,000 | 456.80      | 70.7           | 3                   |
| Set/Existing | 1,000 | 179.03   | 24             | 1                   |
| Set/Existing | 10,000 | 162.60  | 24             | 1                   |
| Set/Existing | 100,000 | 170.93 | 24             | 1                   |

**分析**：
1. **Get/Hit 性能**：查询命中的性能非常高效，平均约97-99ns，且不产生任何内存分配，这对高并发场景下的缓存读取十分有利。
2. **Get/Miss 性能**：查询未命中的性能略低，平均约123-129ns，并有少量内存分配。在较大缓存下（10K+），分配次数降为1次。
3. **Set/New 性能**：添加新条目的性能较低，平均约440-457ns，有较多内存分配（3次，约70-73字节）。
4. **Set/Existing 性能**：更新现有条目比添加新条目快2.5倍左右，仅产生1次内存分配。
5. **缓存大小影响**：缓存大小从1,000到100,000的增长对性能影响相对较小，表明HCache的扩展性良好。

### 1.2 混合负载性能（单线程）

| 操作类型 | 缓存大小 | 读写比例 | 性能 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) |
|---------|---------|----------|-------------|----------------|---------------------|
| Mixed | 1,000 | 80%/20% | 249.17 | 4 | 0 |
| Mixed | 10,000 | 80%/20% | 258.70 | 4 | 0 |
| Mixed | 100,000 | 80%/20% | 332.00 | 4 | 0 |

**分析**：
1. 混合负载（80%读/20%写）下，平均操作延迟约为250-332ns，随着缓存大小增加而略有增长。
2. 内存分配保持在很低的水平（4B/op），且分配次数为0，表明大部分操作复用了已分配的内存。
3. 当缓存大小达到100,000时，性能略有下降（约30%），可能是由于缓存大小增加导致的内存访问模式变化。

### 1.3 淘汰策略性能比较

| 淘汰策略 | 性能 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) |
|---------|-------------|----------------|---------------------|
| LRU     | 123.60      | 12             | 0                   |
| LFU     | 119.03      | 12             | 0                   |
| FIFO    | 119.00      | 12             | 0                   |
| Random  | 118.83      | 12             | 0                   |

**分析**：
1. 四种淘汰策略的性能非常接近，波动在119-124ns之间。
2. FIFO和Random策略性能最佳，可能是因为实现最简单，决策开销最小。
3. LRU策略性能略低（约4-5%），这可能是由于需要维护访问时间戳导致的额外开销。
4. LFU策略的内存占用与其他策略相同（12B/op），这表明HCache在实现LFU时做了优化，避免了额外内存开销。
5. 所有策略的内存分配次数都为0，表明高效的内存复用。

### 1.4 TTL (Time-To-Live) 性能

| 操作 | 性能 (ns/op) | 内存分配 (B/op) | 分配次数 (allocs/op) |
|------|-------------|----------------|---------------------|
| TTL测试 | 42958.33   | 2              | 0                   |

**分析**：
1. TTL测试主要检验缓存过期机制的性能，平均操作延迟约43μs。
2. 与基本操作相比，TTL操作耗时更长，主要是因为涉及时间比较和过期项处理。
3. 内存分配非常少（2B/op），且分配次数为0，表明TTL机制实现高效。

## 2. 对GC (垃圾回收) 的影响

基于上述测试数据，我们可以分析HCache对Go垃圾回收的影响：

1. **读操作对GC影响极小**：Get/Hit操作不分配内存，完全不影响GC；Get/Miss仅产生少量分配。
2. **写操作对GC有中等影响**：Set/New操作每次分配约70字节，在高并发写入场景下可能触发更频繁的GC。
3. **LFU淘汰策略对GC的影响**：LFU策略的内存分配与其他策略相同（12B/op），对GC影响不明显。
4. **混合负载对GC影响小**：混合负载测试中内存分配很少（4B/op），对GC压力较小。
5. **TTL机制对GC影响小**：TTL测试仅分配2字节内存，即使处理大量过期项，对GC影响也很小。

总体而言，HCache在读取操作时对GC几乎没有影响，写入操作时影响中等。在高频写入场景中，应留意可能增加的GC压力。

## 3. 缓存大小对性能的影响

从测试数据中可以观察到：

1. 缓存大小从1,000增加到100,000时：
   - Get/Hit性能变化约1.5%
   - Get/Miss性能实际上略有改善（约3.5%）
   - Set/New性能下降约4%
   - Set/Existing性能波动在10%以内
   - 混合负载性能下降约33%

2. **结论**：
   - 小型缓存（1,000-10,000项）性能几乎相同
   - 大型缓存（100,000项）在混合负载下性能略有下降
   - 缓存大小对单一操作（Get/Set）影响不大
   - 实际应用中，应根据工作集大小和内存限制选择适当的缓存大小

## 4. 分片数量对性能的影响

所有基准测试均使用16个分片，这是HCache默认配置。分片主要用于减少锁竞争，在并发场景中发挥作用。

在单Goroutine基准测试中无法充分体现分片的优势，但在后面的压力测试中，我们将看到分片对并发性能的积极影响。 